{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"getting-started/","text":"Getting started # Welcome to Oktave's Developer Platform! Use our APIs and SDKs to share your surveys on your websites, or by email and text messages, and retrieve responses. Oktave account requirements # All you need is an Enterprise Oktave account to use our APIs \u2014 Embed SDK is available for all Oktave accounts. Some features require an Enterprise account, like Webhooks, and certain Embed modes. Base URL # The base URL for Oktave APIs is https://api.oktave.co/ . Rate limits # Oktave APIs, are rate limited. If you are not using our PHP SDK, be sure to check the headers related to API rate limits X-RateLimit-Limit , X-RateLimit-Remaining , Retry-After . X-RateLimit-Limit - The API rate limit for the current endpoint. X-RateLimit-Remaining - The remaining request count. Retry-After - The delay in seconds before retrying the request. If the API rate limit is reached out, the response use the 429 HTTP code. Ready to use our APIs? # If you don't have an Oktave account, take a quick detour to sign up first. To use Oktave's APIs, you need to create an OAuth 2.0 application that integrates with Oktave. The access_token is automatically managed with our PHP SDK , you do not have to generate it.","title":"Requirements"},{"location":"getting-started/#getting-started","text":"Welcome to Oktave's Developer Platform! Use our APIs and SDKs to share your surveys on your websites, or by email and text messages, and retrieve responses.","title":"Getting started"},{"location":"getting-started/#oktave-account-requirements","text":"All you need is an Enterprise Oktave account to use our APIs \u2014 Embed SDK is available for all Oktave accounts. Some features require an Enterprise account, like Webhooks, and certain Embed modes.","title":"Oktave account requirements"},{"location":"getting-started/#base-url","text":"The base URL for Oktave APIs is https://api.oktave.co/ .","title":"Base URL"},{"location":"getting-started/#rate-limits","text":"Oktave APIs, are rate limited. If you are not using our PHP SDK, be sure to check the headers related to API rate limits X-RateLimit-Limit , X-RateLimit-Remaining , Retry-After . X-RateLimit-Limit - The API rate limit for the current endpoint. X-RateLimit-Remaining - The remaining request count. Retry-After - The delay in seconds before retrying the request. If the API rate limit is reached out, the response use the 429 HTTP code.","title":"Rate limits"},{"location":"getting-started/#ready-to-use-our-apis","text":"If you don't have an Oktave account, take a quick detour to sign up first. To use Oktave's APIs, you need to create an OAuth 2.0 application that integrates with Oktave. The access_token is automatically managed with our PHP SDK , you do not have to generate it.","title":"Ready to use our APIs?"},{"location":"php-sdk/campaigns/","text":"Requirements # Before sending an Oktave campaign (email or text message) you MUST have to configure it on your oktave survey . If you don't know how to create an email or text message campaign, follow these instructions After creating the email or text message campaign, on your Oktave survey share panel, you can send it trought the API channel. When you select the API channel on your Oktave campaign, Oktave gives you an identifier, a UUID to be exact. Recommendations # In order to prevent reaching Oktave API rate, we encourage developers to make their campaign send requests with multiple recipients. For better performance on campaign execution, you can provide a schedulation with a date, this ensure that all recipients provided accross muliple requests will be processing together. Send to a single recipient # try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, 'email@domain.com'); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, '+33612345789'); } catch (\\Throwable $e) { // ... } Send to a single recipient with custom merge map (variables) # try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ 'email' => 'email@domain.com' 'firstname' => 'John', 'lastname' => 'Doe', // ... ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ 'mobile' => '+33612345789' 'firstname' => 'John', 'lastname' => 'Doe', // ... ]); } catch (\\Throwable $e) { // ... } Send to multiple recipients # try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ 'email1@domain.com', 'email2@domain.com', // ... ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ '+33612345789', '+33712345689', // ... ]); } catch (\\Throwable $e) { // ... } Send to multiple recipients with custom merge map (variables) # try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ [ 'email' => 'email1@domain.com' 'firstname' => 'John', 'lastname' => 'Doe', // ... ], [ 'email' => 'email2@domain.com' 'firstname' => 'Jane', 'lastname' => 'Doe', // ... ] ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ [ 'mobile' => '+33612345789' 'firstname' => 'John', 'lastname' => 'Doe', // ... ], [ 'mobile' => '+33712345689' 'firstname' => 'Jane', 'lastname' => 'Doe', // ... ] ]); } catch (\\Throwable $e) { // ... } Schedulation # You can specify a date or a delay to send your campaign. The date value must be type of DateTime , it will be converted to UTC format during the request. The delay value must be type of integer . try { // Schedulation with a date $date = (new DateTime())->add(new DateInterval('P10D')); // 10 days later $oktave->campaigns->send(YOUR_CAMPAIGN_API_UUID, [/* ... */], $date); } catch (\\Throwable $e) { // ... } try { // Schedulation with a delay in seconds $oktave->campaigns->send(YOUR_CAMPAIGN_API_UUID, [/* ... */], 3600); // 1 hour later } catch (\\Throwable $e) { // ... }","title":"Campaigns"},{"location":"php-sdk/campaigns/#requirements","text":"Before sending an Oktave campaign (email or text message) you MUST have to configure it on your oktave survey . If you don't know how to create an email or text message campaign, follow these instructions After creating the email or text message campaign, on your Oktave survey share panel, you can send it trought the API channel. When you select the API channel on your Oktave campaign, Oktave gives you an identifier, a UUID to be exact.","title":"Requirements"},{"location":"php-sdk/campaigns/#recommendations","text":"In order to prevent reaching Oktave API rate, we encourage developers to make their campaign send requests with multiple recipients. For better performance on campaign execution, you can provide a schedulation with a date, this ensure that all recipients provided accross muliple requests will be processing together.","title":"Recommendations"},{"location":"php-sdk/campaigns/#send-to-a-single-recipient","text":"try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, 'email@domain.com'); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, '+33612345789'); } catch (\\Throwable $e) { // ... }","title":"Send to a single recipient"},{"location":"php-sdk/campaigns/#send-to-a-single-recipient-with-custom-merge-map-variables","text":"try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ 'email' => 'email@domain.com' 'firstname' => 'John', 'lastname' => 'Doe', // ... ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ 'mobile' => '+33612345789' 'firstname' => 'John', 'lastname' => 'Doe', // ... ]); } catch (\\Throwable $e) { // ... }","title":"Send to a single recipient with custom merge map (variables)"},{"location":"php-sdk/campaigns/#send-to-multiple-recipients","text":"try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ 'email1@domain.com', 'email2@domain.com', // ... ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ '+33612345789', '+33712345689', // ... ]); } catch (\\Throwable $e) { // ... }","title":"Send to multiple recipients"},{"location":"php-sdk/campaigns/#send-to-multiple-recipients-with-custom-merge-map-variables","text":"try { // For an email campaign $oktave->campaigns->send(YOUR_EMAIL_CAMPAIGN_API_UUID, [ [ 'email' => 'email1@domain.com' 'firstname' => 'John', 'lastname' => 'Doe', // ... ], [ 'email' => 'email2@domain.com' 'firstname' => 'Jane', 'lastname' => 'Doe', // ... ] ]); } catch (\\Throwable $e) { // ... } try { // For a text message campaign $oktave->campaigns->send(YOUR_SMS_CAMPAIGN_API_UUID, [ [ 'mobile' => '+33612345789' 'firstname' => 'John', 'lastname' => 'Doe', // ... ], [ 'mobile' => '+33712345689' 'firstname' => 'Jane', 'lastname' => 'Doe', // ... ] ]); } catch (\\Throwable $e) { // ... }","title":"Send to multiple recipients with custom merge map (variables)"},{"location":"php-sdk/campaigns/#schedulation","text":"You can specify a date or a delay to send your campaign. The date value must be type of DateTime , it will be converted to UTC format during the request. The delay value must be type of integer . try { // Schedulation with a date $date = (new DateTime())->add(new DateInterval('P10D')); // 10 days later $oktave->campaigns->send(YOUR_CAMPAIGN_API_UUID, [/* ... */], $date); } catch (\\Throwable $e) { // ... } try { // Schedulation with a delay in seconds $oktave->campaigns->send(YOUR_CAMPAIGN_API_UUID, [/* ... */], 3600); // 1 hour later } catch (\\Throwable $e) { // ... }","title":"Schedulation"},{"location":"php-sdk/installation/","text":"Requirements # { \"require\": { \"php\": \">=7.3\", \"ext-json\": \"*\" } } Manual installation # You can install the package manually or by adding it to your composer.json : { \"require\": { \"confidencesapp/oktave-sdk-php\": \"^0.3.0\" } } Composer installation # You can install the package with the composer command: $ composer require confidencesapp/oktave-sdk-php","title":"Installation"},{"location":"php-sdk/installation/#requirements","text":"{ \"require\": { \"php\": \">=7.3\", \"ext-json\": \"*\" } }","title":"Requirements"},{"location":"php-sdk/installation/#manual-installation","text":"You can install the package manually or by adding it to your composer.json : { \"require\": { \"confidencesapp/oktave-sdk-php\": \"^0.3.0\" } }","title":"Manual installation"},{"location":"php-sdk/installation/#composer-installation","text":"You can install the package with the composer command: $ composer require confidencesapp/oktave-sdk-php","title":"Composer installation"},{"location":"php-sdk/setup/","text":"Instantiating the SDK Client # Pass in the configuration array to the client: $config = [ 'client_id' => '{your_client_uuid}', 'client_secret' => '{your_client_secret}', 'webhook_secret' => '{your_webhook_secret}', // optional, required for request signature validation ]; $oktave = new Oktave\\Client($config); Or configure after construct: $oktave = new Oktave\\Client() ->setClientID('{your_client_uuid}') ->setClientSecret('{your_client_secret}') ->setWebhookSecret('{your_webhook_secret}'); // optional, required for request signature validation Note: if you are unsure what your client_id , client_secret or webhook_secret are, please go to your Oktave account and copy them. Multiple teams usage # An Oktave account can have multiple teams. Your can interact with all account teams with one OAuth Client. By default the team on which the Oauth client has been created is used. Important We recommend to always use the team_id option. Pass in the team ID to the client: $config = [ // ... 'team_id' => '{your_team_uuid}' // optional, required to specify a team ID ]; $oktave = new Oktave\\Client($config); Or configure after construct: $oktave = new Oktave\\Client($config) ->setTeamId('{your_team_uuid}'); // optional, required to specify a team ID Warning! If no team_id is specified, the team on which the OAuth client has been declared is used by default. Note: if you are unsure what your team_id is, please go to your Oktave account and copy it. Reset to the default team without its ID: // set the team_id to null. $oktave = new Oktave\\Client($config) ->setTeamId(null); Note: the team value can be updated at anytime, for example between resource calls. On-Premise Customers # If you are an on-premise customer and have your own infrastructure with your own domain, you can configure the client to use your domain: $oktave->setBaseURL('https://api.yourdomain.com'); Or by adding the api_endpoint field to the $config array you pass to the constructor.","title":"Configuration"},{"location":"php-sdk/setup/#instantiating-the-sdk-client","text":"Pass in the configuration array to the client: $config = [ 'client_id' => '{your_client_uuid}', 'client_secret' => '{your_client_secret}', 'webhook_secret' => '{your_webhook_secret}', // optional, required for request signature validation ]; $oktave = new Oktave\\Client($config); Or configure after construct: $oktave = new Oktave\\Client() ->setClientID('{your_client_uuid}') ->setClientSecret('{your_client_secret}') ->setWebhookSecret('{your_webhook_secret}'); // optional, required for request signature validation Note: if you are unsure what your client_id , client_secret or webhook_secret are, please go to your Oktave account and copy them.","title":"Instantiating the SDK Client"},{"location":"php-sdk/setup/#multiple-teams-usage","text":"An Oktave account can have multiple teams. Your can interact with all account teams with one OAuth Client. By default the team on which the Oauth client has been created is used. Important We recommend to always use the team_id option. Pass in the team ID to the client: $config = [ // ... 'team_id' => '{your_team_uuid}' // optional, required to specify a team ID ]; $oktave = new Oktave\\Client($config); Or configure after construct: $oktave = new Oktave\\Client($config) ->setTeamId('{your_team_uuid}'); // optional, required to specify a team ID Warning! If no team_id is specified, the team on which the OAuth client has been declared is used by default. Note: if you are unsure what your team_id is, please go to your Oktave account and copy it. Reset to the default team without its ID: // set the team_id to null. $oktave = new Oktave\\Client($config) ->setTeamId(null); Note: the team value can be updated at anytime, for example between resource calls.","title":"Multiple teams usage"},{"location":"php-sdk/setup/#on-premise-customers","text":"If you are an on-premise customer and have your own infrastructure with your own domain, you can configure the client to use your domain: $oktave->setBaseURL('https://api.yourdomain.com'); Or by adding the api_endpoint field to the $config array you pass to the constructor.","title":"On-Premise Customers"},{"location":"php-sdk/usage/","text":"Available resources # For now, there are 3 resources avaible on the Oktave PHP SDK. BlacklistItems - Allow to retrieve all blacklist items for a given team Campaigns - To send email and text message campaigns to your contacts Webhooks - To validate your inbound webhook HTTP requests Pagination # To return a list of your resources without specific pagination values // return a list of your blacklist items $oktave->blacklistItems->all(); To return a paginated list of your resources // return a list of your paginated blacklist items // items per page accepted values : 10, 20, 50, 100 $result = $oktave->blacklistItems->perPage(20)->page(5)->all(); $result->data() // contains the ressource collection $result->meta() // contains the current pagination meta /* [ 'current_page' => 5, 'per_page' => 20, 'total' => 95 ] */ Single Resource by ID # Fetch a Resource by ID: $oktave->blacklistItems->get($blacklistItemID); Handling Exceptions # Aside from errors that may occur due to the call, there may be other Exceptions thrown. To handle them, simply wrap your call in a try catch block: try { $oktave->blacklistItems->all(); } catch (Exception $e) { // do something with $e } Internally, there are several custom Exceptions which may be raised - see the Exceptions directory for more information.","title":"Usage"},{"location":"php-sdk/usage/#available-resources","text":"For now, there are 3 resources avaible on the Oktave PHP SDK. BlacklistItems - Allow to retrieve all blacklist items for a given team Campaigns - To send email and text message campaigns to your contacts Webhooks - To validate your inbound webhook HTTP requests","title":"Available resources"},{"location":"php-sdk/usage/#pagination","text":"To return a list of your resources without specific pagination values // return a list of your blacklist items $oktave->blacklistItems->all(); To return a paginated list of your resources // return a list of your paginated blacklist items // items per page accepted values : 10, 20, 50, 100 $result = $oktave->blacklistItems->perPage(20)->page(5)->all(); $result->data() // contains the ressource collection $result->meta() // contains the current pagination meta /* [ 'current_page' => 5, 'per_page' => 20, 'total' => 95 ] */","title":"Pagination"},{"location":"php-sdk/usage/#single-resource-by-id","text":"Fetch a Resource by ID: $oktave->blacklistItems->get($blacklistItemID);","title":"Single Resource by ID"},{"location":"php-sdk/usage/#handling-exceptions","text":"Aside from errors that may occur due to the call, there may be other Exceptions thrown. To handle them, simply wrap your call in a try catch block: try { $oktave->blacklistItems->all(); } catch (Exception $e) { // do something with $e } Internally, there are several custom Exceptions which may be raised - see the Exceptions directory for more information.","title":"Handling Exceptions"},{"location":"php-sdk/webhooks/","text":"Webhook request verification # To verify a webhook request signature // return true if the request signature is valid $oktave->webhooks->verifySignatureFromGlobals(); This method use global variables to validate the webhook signature. The following global variables are used : $_SERVER['HTTP_OKTAVE_EVENT_ID'] $_SERVER['HTTP_OKTAVE_TIMESTAMP'] $_SERVER['HTTP_OKTAVE_SIGNATURE'] You can manually check the webhook request like this : $eventID = isset($_SERVER['HTTP_OKTAVE_EVENT_ID']) ? $_SERVER['HTTP_OKTAVE_EVENT_ID'] : null; $requestTimestamp = isset($_SERVER['HTTP_OKTAVE_TIMESTAMP']) ? (int) $_SERVER['HTTP_OKTAVE_TIMESTAMP'] : null; $signature = isset($_SERVER['HTTP_OKTAVE_SIGNATURE']) ? $_SERVER['HTTP_OKTAVE_SIGNATURE'] : null; // return true if the request signature is valid $oktave->webhooks->verifySignature($eventID, $requestTimestamp, $signature);","title":"Webhook Verification"},{"location":"php-sdk/webhooks/#webhook-request-verification","text":"To verify a webhook request signature // return true if the request signature is valid $oktave->webhooks->verifySignatureFromGlobals(); This method use global variables to validate the webhook signature. The following global variables are used : $_SERVER['HTTP_OKTAVE_EVENT_ID'] $_SERVER['HTTP_OKTAVE_TIMESTAMP'] $_SERVER['HTTP_OKTAVE_SIGNATURE'] You can manually check the webhook request like this : $eventID = isset($_SERVER['HTTP_OKTAVE_EVENT_ID']) ? $_SERVER['HTTP_OKTAVE_EVENT_ID'] : null; $requestTimestamp = isset($_SERVER['HTTP_OKTAVE_TIMESTAMP']) ? (int) $_SERVER['HTTP_OKTAVE_TIMESTAMP'] : null; $signature = isset($_SERVER['HTTP_OKTAVE_SIGNATURE']) ? $_SERVER['HTTP_OKTAVE_SIGNATURE'] : null; // return true if the request signature is valid $oktave->webhooks->verifySignature($eventID, $requestTimestamp, $signature);","title":"Webhook request verification"},{"location":"webhooks/configuration/","text":"Webhook # Oktave webhooks allow you to listen events on your application by receiving incoming requests sent by Oktave application. Requests use the POST HTTP method and data are formatted using JSON . Configuration # Oktave webhooks can be configured on your survey or account configuration page. About CSRF protection If you have a CSRF protection on your application, you should disable it for your webhook handler route. Validating webhook origin # Oktave webhooks are always signed using your webhook secret key (available on your account page). This allows you to validate that the events you receive are really sent by Oktave application. You SHOULD use the signature to verify provenance of webhooks . Here is an example of signature validation using our PHP SDK . $config = [ 'webhook_secret' => '{your_webhook_secret}', // Other options not required for webhook validation ]; $oktave = new Oktave\\Client($config); // return true if the request signature is valid $oktave->webhooks->verifySignatureFromGlobals(); More than signature verification, you should also check that the received event is not too old or that you do not already received it.","title":"Configuration"},{"location":"webhooks/configuration/#webhook","text":"Oktave webhooks allow you to listen events on your application by receiving incoming requests sent by Oktave application. Requests use the POST HTTP method and data are formatted using JSON .","title":"Webhook"},{"location":"webhooks/configuration/#configuration","text":"Oktave webhooks can be configured on your survey or account configuration page. About CSRF protection If you have a CSRF protection on your application, you should disable it for your webhook handler route.","title":"Configuration"},{"location":"webhooks/configuration/#validating-webhook-origin","text":"Oktave webhooks are always signed using your webhook secret key (available on your account page). This allows you to validate that the events you receive are really sent by Oktave application. You SHOULD use the signature to verify provenance of webhooks . Here is an example of signature validation using our PHP SDK . $config = [ 'webhook_secret' => '{your_webhook_secret}', // Other options not required for webhook validation ]; $oktave = new Oktave\\Client($config); // return true if the request signature is valid $oktave->webhooks->verifySignatureFromGlobals(); More than signature verification, you should also check that the received event is not too old or that you do not already received it.","title":"Validating webhook origin"},{"location":"webhooks/events/","text":"Events # Oktave webhooks can dispatch the following events. response.started # When someone started responding to one of your survey. The data will contains a Reponse object. Some Answer can be present (when answered from email content) response.completed # When someone finished completing one of your survey. The data will contains a Reponse object. All Answer are available answer.saved # When someone answer to one of the questions of your survey. The data will contains an Answer object. This event is very limited in its data structure. blacklist_item.created # When one of your survey campaign's contact is bounced or unsubscribed. The data will contains a Blacklist Item object. This event won't be emitted on a manual import of blacklist items incident.created # When one of your survey triggered a new incident from configured survey's alerts. The data will contains an Incident object. The incident center is an on-demande feature. incident.updated # When one of your incident is updated (a comment is created on it). The data will contains an Incident object. The incident center is an on-demande feature.","title":"Events"},{"location":"webhooks/events/#events","text":"Oktave webhooks can dispatch the following events.","title":"Events"},{"location":"webhooks/events/#responsestarted","text":"When someone started responding to one of your survey. The data will contains a Reponse object. Some Answer can be present (when answered from email content)","title":"response.started"},{"location":"webhooks/events/#responsecompleted","text":"When someone finished completing one of your survey. The data will contains a Reponse object. All Answer are available","title":"response.completed"},{"location":"webhooks/events/#answersaved","text":"When someone answer to one of the questions of your survey. The data will contains an Answer object. This event is very limited in its data structure.","title":"answer.saved"},{"location":"webhooks/events/#blacklist_itemcreated","text":"When one of your survey campaign's contact is bounced or unsubscribed. The data will contains a Blacklist Item object. This event won't be emitted on a manual import of blacklist items","title":"blacklist_item.created"},{"location":"webhooks/events/#incidentcreated","text":"When one of your survey triggered a new incident from configured survey's alerts. The data will contains an Incident object. The incident center is an on-demande feature.","title":"incident.created"},{"location":"webhooks/events/#incidentupdated","text":"When one of your incident is updated (a comment is created on it). The data will contains an Incident object. The incident center is an on-demande feature.","title":"incident.updated"},{"location":"webhooks/objects/","text":"Objects # Here is all the objects structure that can be received through webhooks : Answer : contains an answer to a question of the survey. Blacklist Item : contains a recipient who was blacklisted from survey sending (email or text message). Campaign : contains a survey campaign which allow to share the survey through channels. Text Message Campaign : contains a text message campaign which allow to send simple text message. Choice : contains a choice from a survey question (MCQ, Picture or Rank). Comment : contains a comment to an incident object. Component : contains a survey question. Field : contains a field from a survey question. Grid Item : contains one grid item from a survey question when component has grid. Incident : contains an incident triggered from survey alerts configuration. Response : contains a response to the survey. User Agent : contains the user agent data. About object properties typing Some property are optional , marked with ? after the type hint, which means the property can be absent from payload. Some property contains a list of object, marked with * after the type hint. Some property can have null as a value, marked with null type hint. About datetime of objects All datetime are given as timestamp using UTC+00:00 Timezone. Answer # id [UUID] : the answer ID. response_id [UUID] : the response ID. is_embedded [boolean] : if the answer was created before the survey opening (in an email for example). is_ignored [boolean] : if the user choose to ignore the question (if as true value, none value of answer will be given, such as as_string , comment , number ...). component [Component] : the component this answer is for. grid_item [GridItem?] : the component this answer is for (defined if component.has_grid is true). created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. comment [string?] : the comment (defined when not ignored and component allows comment and if comment is defined). as_string [string?] : the human readable string representation of this answer (defined when not ignored). text [string|null?] : a textual answer (when not ignored and component.component_type is short-answer ). choices [Choice*?] : a list of choices (when component.component_type is mcq , mcq-picture or rank ). When component.component_type is rank , the list will be ordered by choice rank instead of position. number [int|null?] : a number answer (when component.component_type is rating , nps or smiley ). fields [Field*?] : a list of fields (when component.component_type is form ). Blacklist Item # id [UUID] : the blacklist item ID. recipient_type [string] : the type of the recipient column ( email or mobile ). recipient [string] : the email address or phone number. campaign [ Campaign | Text Message Campaign ]: the related campaign object. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. status [string] : the reason this recipient was added to the blacklist ( soft_bounced , hard_bounced or unsubscribed ). bounce_reason [string?] : the reason it was soft bounced or hard bounced (defined when status is soft_bounced or hard_bounced ). soft_bounced_at [timestamp?] : the soft bounce datetime (defined when status is soft_bounced or hard_bounced ). hard_bounced_at [timestamp?] : the hard bounce datetime (defined when status is soft_bounced or hard_bounced ). unsubscribed_at [timestamp?] : the unsubscribe datetime (defined when status is unsubscribed ). Campaign # id [UUID] : the campaign ID. token [string] : the unique token. channel [string] : the channel ( url , email , sms , keyword , kiosk , iframe , qrcode , facebook , popin ). survey_id [UUID] : the survey ID. survey_name [string|null] : the survey name. Text Message Campaign # id [UUID] : the campaign ID. name [string] : the campaign name. sender [string] : the text message sender. text_message [string] : the text message content. Choice # id [UUID] : the choice ID. text [string|null] : the textual content. When is_other is true , this is the content written by the user. is_other [boolean] : if the choice corresponds to an other selection written by the user. rank [int?] : the rank of this choice in list (when related component.component_type is rank ). Comment # id [UUID] : the comment ID. status [string] : describes the incident status at this comment step (see Incident latest_status field). body [string] : the content of the comment. incident_id [UUID] : the parent incident ID. solver [string] : the name/pseudo of the comment's author. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. Component # id [UUID] : the component ID. required [boolean] : If an answer is required. title [string|null] : the component title. position [int] : the position in the survey. component_type [string] : the type ( short-answer , mcq , mcq-picture , rank , rating , nps , smiley , form ). type_changed [boolean] : if the type changed since the answer has been created (defined when nested in answer). has_grid [boolean] : if the component uses grid item. multiple_answers [boolean?] : if the component allows multiple choices (when component.component_type is mcq , mcq-picture or rank ). min_answers [int?] : the number of minimum choices (defined when multiple_answers is true ). max_answers [int?] : the number of maximum choices (defined when multiple_answers is true ). shape [string?] : the icons used to display the list of values (when component.component_type is rating , nps or smiley ). minimum [int?] : the minimum value (when component.component_type is rating or nps ). maximum [int?] : the maximum value (when component.component_type is rating or nps ). possible_values [int*?] : the possible values (when component.component_type is smiley ). Field # id [UUID] : the choice ID (because a field is just a choice related to a form component). required [boolean] : if the field is required. type [string] : the type to validate ( text , number , email , phone , url , date ). text [string] : the title of the field. value [string|null] : an answer to the field. Grid Item # id [UUID] : the grid item ID. text [string|null] : the component text. Incident # id [UUID] : the incident ID. latest_status [string] : the last status of the incident. new means it has never been commented. opened means it has been commented but is still opened. solved means it is solved. archived means it has been archived. title [string] : the raw title of the incident (raw because it is not merged with response data like in email version of incident). body [string] : the raw body of the incident (raw because it is not merged with response data like in email version of incident). comments_count [int] : the number of comment on this incident. comments [Comment*] : the related comment objects. response [Response] : the related response object which triggered the incident. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. Response # id [UUID] : the response ID. campaign [Campaign] : the related campaign object. user_agent [User Agent?] : the related user agent object. status [string] : the status ( opened , started , completed ). language [string] : the selected language by the user or the default language of survey. unique_identifier [string|null] : the unique identifier for this response. contact_id [string|null] : the internal contact ID (defined when campaign is with channel email or sms ). sequence_id [string|null] : the sending sequence ID (defined when campaign is with channel email or sms ). merge_fields [Object] : The merge map data as a key-value pair hash. Key are in snake case. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. started_at [timestamp|null] : the start datetime (defined when the status is started or completed ). completed_at [timestamp|null] : the completion datetime (defined when the status is completed ). answers [Answer*] : the related answers objects. User Agent # browser [string] : the browser name (ex. Chrome). browser_version [string] : the browser version number. os [string] : the Operating System name (ex. macOS). os_version [string] : the Operating System version number. device_name [string] : the device name (ex. iPhone). device_type [string] : the device type (ex. Mobile Phone). ip_address [string] : the IP address (ex. 127.0.0.1).","title":"Objects"},{"location":"webhooks/objects/#objects","text":"Here is all the objects structure that can be received through webhooks : Answer : contains an answer to a question of the survey. Blacklist Item : contains a recipient who was blacklisted from survey sending (email or text message). Campaign : contains a survey campaign which allow to share the survey through channels. Text Message Campaign : contains a text message campaign which allow to send simple text message. Choice : contains a choice from a survey question (MCQ, Picture or Rank). Comment : contains a comment to an incident object. Component : contains a survey question. Field : contains a field from a survey question. Grid Item : contains one grid item from a survey question when component has grid. Incident : contains an incident triggered from survey alerts configuration. Response : contains a response to the survey. User Agent : contains the user agent data. About object properties typing Some property are optional , marked with ? after the type hint, which means the property can be absent from payload. Some property contains a list of object, marked with * after the type hint. Some property can have null as a value, marked with null type hint. About datetime of objects All datetime are given as timestamp using UTC+00:00 Timezone.","title":"Objects"},{"location":"webhooks/objects/#answer","text":"id [UUID] : the answer ID. response_id [UUID] : the response ID. is_embedded [boolean] : if the answer was created before the survey opening (in an email for example). is_ignored [boolean] : if the user choose to ignore the question (if as true value, none value of answer will be given, such as as_string , comment , number ...). component [Component] : the component this answer is for. grid_item [GridItem?] : the component this answer is for (defined if component.has_grid is true). created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. comment [string?] : the comment (defined when not ignored and component allows comment and if comment is defined). as_string [string?] : the human readable string representation of this answer (defined when not ignored). text [string|null?] : a textual answer (when not ignored and component.component_type is short-answer ). choices [Choice*?] : a list of choices (when component.component_type is mcq , mcq-picture or rank ). When component.component_type is rank , the list will be ordered by choice rank instead of position. number [int|null?] : a number answer (when component.component_type is rating , nps or smiley ). fields [Field*?] : a list of fields (when component.component_type is form ).","title":"Answer"},{"location":"webhooks/objects/#blacklist-item","text":"id [UUID] : the blacklist item ID. recipient_type [string] : the type of the recipient column ( email or mobile ). recipient [string] : the email address or phone number. campaign [ Campaign | Text Message Campaign ]: the related campaign object. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. status [string] : the reason this recipient was added to the blacklist ( soft_bounced , hard_bounced or unsubscribed ). bounce_reason [string?] : the reason it was soft bounced or hard bounced (defined when status is soft_bounced or hard_bounced ). soft_bounced_at [timestamp?] : the soft bounce datetime (defined when status is soft_bounced or hard_bounced ). hard_bounced_at [timestamp?] : the hard bounce datetime (defined when status is soft_bounced or hard_bounced ). unsubscribed_at [timestamp?] : the unsubscribe datetime (defined when status is unsubscribed ).","title":"Blacklist Item"},{"location":"webhooks/objects/#campaign","text":"id [UUID] : the campaign ID. token [string] : the unique token. channel [string] : the channel ( url , email , sms , keyword , kiosk , iframe , qrcode , facebook , popin ). survey_id [UUID] : the survey ID. survey_name [string|null] : the survey name.","title":"Campaign"},{"location":"webhooks/objects/#text-message-campaign","text":"id [UUID] : the campaign ID. name [string] : the campaign name. sender [string] : the text message sender. text_message [string] : the text message content.","title":"Text Message Campaign"},{"location":"webhooks/objects/#choice","text":"id [UUID] : the choice ID. text [string|null] : the textual content. When is_other is true , this is the content written by the user. is_other [boolean] : if the choice corresponds to an other selection written by the user. rank [int?] : the rank of this choice in list (when related component.component_type is rank ).","title":"Choice"},{"location":"webhooks/objects/#comment","text":"id [UUID] : the comment ID. status [string] : describes the incident status at this comment step (see Incident latest_status field). body [string] : the content of the comment. incident_id [UUID] : the parent incident ID. solver [string] : the name/pseudo of the comment's author. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime.","title":"Comment"},{"location":"webhooks/objects/#component","text":"id [UUID] : the component ID. required [boolean] : If an answer is required. title [string|null] : the component title. position [int] : the position in the survey. component_type [string] : the type ( short-answer , mcq , mcq-picture , rank , rating , nps , smiley , form ). type_changed [boolean] : if the type changed since the answer has been created (defined when nested in answer). has_grid [boolean] : if the component uses grid item. multiple_answers [boolean?] : if the component allows multiple choices (when component.component_type is mcq , mcq-picture or rank ). min_answers [int?] : the number of minimum choices (defined when multiple_answers is true ). max_answers [int?] : the number of maximum choices (defined when multiple_answers is true ). shape [string?] : the icons used to display the list of values (when component.component_type is rating , nps or smiley ). minimum [int?] : the minimum value (when component.component_type is rating or nps ). maximum [int?] : the maximum value (when component.component_type is rating or nps ). possible_values [int*?] : the possible values (when component.component_type is smiley ).","title":"Component"},{"location":"webhooks/objects/#field","text":"id [UUID] : the choice ID (because a field is just a choice related to a form component). required [boolean] : if the field is required. type [string] : the type to validate ( text , number , email , phone , url , date ). text [string] : the title of the field. value [string|null] : an answer to the field.","title":"Field"},{"location":"webhooks/objects/#grid-item","text":"id [UUID] : the grid item ID. text [string|null] : the component text.","title":"Grid Item"},{"location":"webhooks/objects/#incident","text":"id [UUID] : the incident ID. latest_status [string] : the last status of the incident. new means it has never been commented. opened means it has been commented but is still opened. solved means it is solved. archived means it has been archived. title [string] : the raw title of the incident (raw because it is not merged with response data like in email version of incident). body [string] : the raw body of the incident (raw because it is not merged with response data like in email version of incident). comments_count [int] : the number of comment on this incident. comments [Comment*] : the related comment objects. response [Response] : the related response object which triggered the incident. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime.","title":"Incident"},{"location":"webhooks/objects/#response","text":"id [UUID] : the response ID. campaign [Campaign] : the related campaign object. user_agent [User Agent?] : the related user agent object. status [string] : the status ( opened , started , completed ). language [string] : the selected language by the user or the default language of survey. unique_identifier [string|null] : the unique identifier for this response. contact_id [string|null] : the internal contact ID (defined when campaign is with channel email or sms ). sequence_id [string|null] : the sending sequence ID (defined when campaign is with channel email or sms ). merge_fields [Object] : The merge map data as a key-value pair hash. Key are in snake case. created_at [timestamp] : the creation datetime. updated_at [timestamp] : the last update datetime. started_at [timestamp|null] : the start datetime (defined when the status is started or completed ). completed_at [timestamp|null] : the completion datetime (defined when the status is completed ). answers [Answer*] : the related answers objects.","title":"Response"},{"location":"webhooks/objects/#user-agent","text":"browser [string] : the browser name (ex. Chrome). browser_version [string] : the browser version number. os [string] : the Operating System name (ex. macOS). os_version [string] : the Operating System version number. device_name [string] : the device name (ex. iPhone). device_type [string] : the device type (ex. Mobile Phone). ip_address [string] : the IP address (ex. 127.0.0.1).","title":"User Agent"},{"location":"webhooks/payload/","text":"Payload structure # The JSON payload content will always have the same root structure: id [UUID] : The ID of the request (difference the multiple event request attempt). event_id [UUID] : The ID of the event. timestamp [timestamp] : The creation datetime of event. type [string] : The type of the event (see Events section). is_test [boolean] : Tells if this event is a test. data [Object] : The object this event is about (see Events section to know which object will be in it).","title":"Payload"},{"location":"webhooks/payload/#payload-structure","text":"The JSON payload content will always have the same root structure: id [UUID] : The ID of the request (difference the multiple event request attempt). event_id [UUID] : The ID of the event. timestamp [timestamp] : The creation datetime of event. type [string] : The type of the event (see Events section). is_test [boolean] : Tells if this event is a test. data [Object] : The object this event is about (see Events section to know which object will be in it).","title":"Payload structure"}]}